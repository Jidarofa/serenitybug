"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementArrayListAdapter = void 0;
const core_1 = require("@serenity-js/core");
const io_1 = require("@serenity-js/core/lib/io");
/**
 * @desc
 *  Adapts {@link ElementArray} so that it can be used with {@link @serenity-js/core/lib/screenplay/questions~List}.
 *
 *  You most likely won't need to use this class directly. Instead, check out {@link Target} and {@link Target.all}.
 *
 * @see {@link Target}
 *
 * @implements {@serenity-js/core/lib/screenplay/questions/lists~ListAdapter}
 */
class ElementArrayListAdapter {
    constructor(collection) {
        this.collection = collection;
    }
    /**
     * @desc
     *  Returns the number of {@link Element}s that the underlying {@link ElementArray} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<number>}
     */
    async count(actor) {
        const elements = await this.elements(actor);
        return elements.length;
    }
    /**
     * @desc
     *  Returns the first of {@link Element}s that the underlying {@link ElementArray} contains,
     *  left after applying any filters
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Element<'async'>}
     */
    async first(actor) {
        const elements = await this.elements(actor);
        return elements[0];
    }
    /**
     * @desc
     *  Returns the last of {@link Element}s that the underlying {@link ElementArray} contains,
     *  left after applying any filters
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Element<'async'>}
     */
    async last(actor) {
        const elements = await this.elements(actor);
        return elements[elements.length - 1];
    }
    /**
     * @desc
     *  Returns the nth of {@link Element}s that the underlying {@link ElementArray} contains,
     *  left after applying any filters
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     *
     * @param {number} index
     *  Zero-based index of the item to return
     *
     * @returns {Element<'async'>}
     */
    async get(actor, index) {
        const elements = await this.elements(actor);
        return elements[index];
    }
    /**
     * @desc
     *  Returns the underlying {@link ElementArray},
     *  with any filters applied.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Element<'async'>}
     */
    items(actor) {
        return this.elements(actor);
    }
    /**
     * @desc
     *  Filters the underlying {@link ElementArray} so that the result contains only those {@link Element<'async'>}s that meet the {@link Expectation}
     *
     * @param {@serenity-js/core/lib/screenplay/questions~MetaQuestion<Answerable<Element<'async'>>, Promise<Answer_Type> | Answer_Type>} question
     * @param {@serenity-js/core/lib/screenplay/questions~Expectation<any, Answer_Type>} expectation
     *
     * @returns {@serenity-js/core/lib/screenplay/questions/lists~ListAdapter<Element<'async'>, ElementArrayFinder>}
     *
     * @see {@link @serenity-js/core/lib/screenplay/questions~MetaQuestion}
     */
    withFilter(question, expectation) {
        return new ElementArrayListAdapter(new ElementArrayListFilter(this.collection, question, expectation));
    }
    /**
     * @desc
     *  Returns a human-readable description of the underlying {@link ElementArray}.
     *
     * @returns {string}
     */
    toString() {
        return (0, io_1.formatted) `${this.collection}`;
    }
    elements(actor) {
        return actor.answer(this.collection);
    }
}
exports.ElementArrayListAdapter = ElementArrayListAdapter;
/**
 * @private
 */
class ElementArrayListFilter extends core_1.Question {
    constructor(collection, question, expectation) {
        super([
            (0, io_1.formatted) `${collection}`,
            collection instanceof ElementArrayListFilter ? 'and' : 'where',
            (0, io_1.formatted) `${question} does ${expectation}`
        ].join(' '));
        this.collection = collection;
        this.question = question;
        this.expectation = expectation;
    }
    async answeredBy(actor) {
        const collection = await actor.answer(this.collection);
        const outcomes = await Promise.all(collection.map((element) => actor.answer(this.question.of(element))
            .then((answer) => this.expectation.answeredBy(actor)(answer))));
        const matching = collection.filter((element, index) => outcomes[index] instanceof core_1.ExpectationMet);
        matching.selector = collection.selector;
        matching.parent = collection.parent;
        matching.foundWith = collection.foundWith;
        matching.props = collection.props;
        return matching;
    }
}
//# sourceMappingURL=lists.js.map