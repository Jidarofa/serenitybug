"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhotoTakingStrategy = void 0;
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const screenplay_1 = require("../../../../screenplay");
/**
 * @desc
 *  Configures the {@link Photographer} to take photos (a.k.a. screenshots)
 *  of the {@link @serenity-js/core/lib/screenplay~Activity} performed
 *  by the {@link @serenity-js/core/lib/screenplay/actor~Actor} in the spotlight
 *  under specific conditions.
 *
 * @abstract
 */
class PhotoTakingStrategy {
    /**
     * @desc
     *  Takes a photo of the web browser held by the {@link @serenity-js/core/lib/screenplay/actor~Actor} in the spotlight.
     *
     * @param {@serenity-js/core/lib/events~ActivityStarts | @serenity-js/core/lib/events~ActivityFinished} event
     * @param {@serenity-js/core/lib/stage~Stage} stage - the Stage that holds reference to the Actor in the spotlight
     * @returns {void}
     *
     * @see {@link @serenity-js/core/lib/stage~Stage#theActorInTheSpotlight}
     */
    considerTakingPhoto(event, stage) {
        if (this.shouldTakeAPhotoOf(event)) {
            let browseTheWeb;
            try {
                browseTheWeb = screenplay_1.BrowseTheWeb.as(stage.theActorInTheSpotlight());
            }
            catch {
                return void 0;
            }
            const id = model_1.CorrelationId.create(), nameSuffix = this.photoNameFor(event), 
            // todo: test if this type def is really DesiredCapabilities when multi-capabilities are used
            capabilities = browseTheWeb.browser.capabilities;
            stage.announce(new events_1.AsyncOperationAttempted(new model_1.Description(`[Photographer:${this.constructor.name}] Taking screenshot of '${nameSuffix}'...`), id));
            browseTheWeb.takeScreenshot().then(screenshot => {
                const context = [capabilities.platformName, capabilities.browserName, capabilities.browserVersion], photoName = this.combinedNameFrom(...context, nameSuffix);
                stage.announce(new events_1.ActivityRelatedArtifactGenerated(event.sceneId, event.activityId, photoName, model_1.Photo.fromBase64(screenshot)));
                stage.announce(new events_1.AsyncOperationCompleted(new model_1.Description(`[${this.constructor.name}] Took screenshot of '${nameSuffix}' on ${context}`), id));
            }).catch(error => {
                if (this.shouldIgnore(error)) {
                    stage.announce(new events_1.AsyncOperationCompleted(new model_1.Description(`[${this.constructor.name}] Aborted taking screenshot of '${nameSuffix}' because of ${error.constructor && error.constructor.name}`), id));
                }
                else {
                    stage.announce(new events_1.AsyncOperationFailed(error, id));
                }
            });
        }
    }
    combinedNameFrom(...parts) {
        return new model_1.Name(parts.filter(v => !!v).join('-'));
    }
    shouldIgnore(error) {
        // todo
        // return error instanceof webdriver.NoSuchSessionError
        //     || error instanceof webdriver.UnexpectedAlertOpenError
        return false;
    }
}
exports.PhotoTakingStrategy = PhotoTakingStrategy;
//# sourceMappingURL=PhotoTakingStrategy.js.map