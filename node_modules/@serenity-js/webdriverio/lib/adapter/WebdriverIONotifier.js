"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebdriverIONotifier = void 0;
const core_1 = require("@serenity-js/core");
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const tiny_types_1 = require("tiny-types");
/**
 * @package
 */
class WebdriverIONotifier {
    constructor(reporter, successThreshold, cid, specs, failures = 0, stage) {
        this.reporter = reporter;
        this.successThreshold = successThreshold;
        this.cid = cid;
        this.specs = specs;
        this.failures = failures;
        this.stage = stage;
        this.events = new EventLog();
        this.suites = [];
    }
    assignedTo(stage) {
        this.stage = stage;
        return this;
    }
    notifyOf(event) {
        return (0, tiny_types_1.match)(event)
            .when(events_1.TestSuiteStarts, WebdriverIONotifier.prototype.onTestSuiteStarts.bind(this))
            .when(events_1.TestSuiteFinished, WebdriverIONotifier.prototype.onTestSuiteFinished.bind(this))
            .when(events_1.SceneStarts, WebdriverIONotifier.prototype.onSceneStarts.bind(this))
            .when(events_1.SceneFinished, WebdriverIONotifier.prototype.onSceneFinished.bind(this))
            .else(() => void 0);
    }
    failureCount() {
        return this.failures;
    }
    onTestSuiteStarts(started) {
        this.events.record(started.details.correlationId, started);
        this.reporter.emit('suite:start', this.suiteStartEventFrom(started));
        this.suites.push(started.details);
    }
    onTestSuiteFinished(finished) {
        this.suites.pop();
        const started = this.events.getByCorrelationId(finished.details.correlationId);
        this.reporter.emit('suite:end', this.suiteEndEventFrom(started, finished));
    }
    suiteStartEventFrom(started) {
        return {
            type: 'suite:start',
            uid: started.details.correlationId.value,
            cid: this.cid,
            title: started.details.name.value,
            fullTitle: this.suiteNamesConcatenatedWith(started.details.name.value),
            parent: this.parentSuiteName(),
            file: started.details.location.path.value,
            specs: this.specs,
            pending: false,
        };
    }
    suiteNamesConcatenatedWith(name) {
        return this.suites.map(suite => suite.name.value).concat(name).join(' ');
    }
    suiteEndEventFrom(started, finished) {
        return {
            ...this.suiteStartEventFrom(started),
            type: 'suite:end',
            duration: finished.timestamp.diff(started.timestamp).inMilliseconds()
        };
    }
    onSceneStarts(started) {
        const test = this.testStartEventFrom(started);
        this.events.record(started.sceneId, started);
        this.reporter.emit(test.type, test);
    }
    onSceneFinished(finished) {
        if (finished.outcome.isWorseThan(this.successThreshold)) {
            this.failures++;
        }
        const started = this.events.getByCorrelationId(finished.sceneId);
        if (this.willBeRetried(finished.outcome)) {
            const testResult = this.testEndEventFrom(started, finished);
            const type = 'test:retry';
            this.reporter.emit(type, {
                ...testResult,
                type,
                error: this.errorFrom(finished.outcome),
            });
        }
        else {
            const testResult = this.testResultEventFrom(started, finished);
            this.reporter.emit(testResult.type, testResult);
            const testEnd = this.testEndEventFrom(started, finished);
            this.reporter.emit(testEnd.type, testEnd);
        }
    }
    willBeRetried(outcome) {
        return outcome instanceof model_1.ExecutionIgnored;
    }
    testStartEventFrom(started) {
        const title = started.details.name.value
            .replace(new RegExp(`^.*?(${this.parentSuiteName()})`), '')
            .trim();
        return {
            type: 'test:start',
            title,
            fullTitle: this.suiteNamesConcatenatedWith(title),
            parent: this.parentSuiteName(),
            file: started.details.location.path.value,
            pending: false,
            cid: this.cid,
            uid: started.sceneId.value,
            specs: this.specs,
        };
    }
    parentSuiteName() {
        var _a;
        return ((_a = this.suites[this.suites.length - 1]) === null || _a === void 0 ? void 0 : _a.name.value) || '';
    }
    testEndEventFrom(started, finished) {
        const duration = finished.timestamp.diff(started.timestamp).inMilliseconds();
        return {
            ...this.testStartEventFrom(started),
            type: 'test:end',
            duration
        };
    }
    testResultEventFrom(started, finished) {
        const test = this.testEndEventFrom(started, finished);
        const unlessSuccessful = (outcome, type) => !outcome.isWorseThan(this.successThreshold) && (outcome instanceof model_1.ProblemIndication)
            ? 'test:pass'
            : type;
        return (0, tiny_types_1.match)(finished.outcome)
            .when(model_1.ExecutionCompromised, (outcome) => ({
            ...test,
            type: unlessSuccessful(outcome, 'test:fail'),
            error: this.errorFrom(outcome),
        }))
            .when(model_1.ExecutionFailedWithError, (outcome) => ({
            ...test,
            type: unlessSuccessful(outcome, 'test:fail'),
            error: this.errorFrom(outcome),
        }))
            .when(model_1.ExecutionFailedWithAssertionError, (outcome) => ({
            ...test,
            type: unlessSuccessful(outcome, 'test:fail'),
            error: this.errorFrom(outcome),
        }))
            .when(model_1.ImplementationPending, (outcome) => ({
            ...test,
            type: unlessSuccessful(outcome, 'test:pending'),
            error: this.errorFrom(outcome),
            pending: true,
            pendingReason: outcome.error.message
        }))
            .when(model_1.ExecutionIgnored, (outcome) => ({
            ...test,
            // In WebdriverIO, skipped == pending == ignored
            // https://github.com/webdriverio/webdriverio/blob/a1830046f367be7737af2c00561796c3ae5dd85b/packages/wdio-reporter/src/index.ts#L162
            type: unlessSuccessful(outcome, 'test:pending'),
            error: this.errorFrom(outcome),
            pending: true,
            pendingReason: outcome.error.message
        }))
            .when(model_1.ExecutionSkipped, (outcome) => ({
            ...test,
            // In WebdriverIO, skipped == pending == ignored
            // https://github.com/webdriverio/webdriverio/blob/a1830046f367be7737af2c00561796c3ae5dd85b/packages/wdio-reporter/src/index.ts#L162
            type: unlessSuccessful(outcome, 'test:pending'),
            pending: true,
        }))
            .else(() => ({
            ...test,
            type: 'test:pass',
        }));
    }
    errorFrom(outcome) {
        const error = outcome.error;
        // https://github.com/webdriverio/webdriverio/blob/7ec2c60a7623de431d60bb3605957e6e4bdf057b/packages/wdio-mocha-framework/src/index.ts#L233
        return {
            name: error.name,
            message: error.message,
            stack: error.stack,
            type: error.type || error.name,
            expected: error.expected,
            actual: error.actual
        };
    }
}
exports.WebdriverIONotifier = WebdriverIONotifier;
class EventLog {
    constructor() {
        this.events = new Map();
    }
    record(correlationId, event) {
        this.events.set(correlationId.value, event);
    }
    getByCorrelationId(correlationId) {
        if (!this.events.has(correlationId.value)) {
            throw new core_1.LogicError(`Event with correlation id ${correlationId} has never been recorded`);
        }
        return this.events.get(correlationId.value);
    }
}
//# sourceMappingURL=WebdriverIONotifier.js.map